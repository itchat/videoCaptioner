from PyQt6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QComboBox,
    QScrollArea,
    QMessageBox,
    QApplication,
)
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QKeySequence, QAction, QShortcut
import os
import platform
import subprocess
from .drop_area import DropArea
from .progress_widget import ProgressWidget
from .api_settings_dialog import ApiSettingsDialog
from .download_dialog import DownloadDialog
from core.video_processor import MultiprocessVideoManager
from config import OPENAI_BASE_URL, OPENAI_API_KEY, OPENAI_MODEL, OPENAI_CUSTOM_PROMPT, OPENAI_MAX_CHARS_PER_BATCH, OPENAI_MAX_ENTRIES_PER_BATCH, MAX_PROCESSES, save_config
import multiprocessing as mp


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.central_widget = SubtitleProcessor()
        self.setCentralWidget(self.central_widget)
        self.init_window()

    def init_window(self):
        # self.setWindowTitle("videoCaptioner")
        self.setMinimumSize(350, 350)  # ËÆæÁΩÆÊúÄÂ∞èÁ™óÂè£Â§ßÂ∞è
        # self.resize(400, 400)  # ËÆæÁΩÆÈªòËÆ§Á™óÂè£Â§ßÂ∞è

        # Set the window icon
        self.setWindowFlags(Qt.WindowType.Window)

        # Create menu bar with quit action for macOS
        self.create_menu_actions()

        # Add Command+Q shortcut for macOS
        self.quit_shortcut = QShortcut(QKeySequence("Ctrl+Q"), self)
        self.quit_shortcut.activated.connect(self.close)

        # Add Command+Q shortcut specifically for macOS
        self.quit_shortcut_mac = QShortcut(QKeySequence("Meta+Q"), self)
        self.quit_shortcut_mac.activated.connect(self.close)

    def create_menu_actions(self):
        # Create File menu with Quit action
        file_menu = self.menuBar().addMenu("File")

        # Create Quit action
        quit_action = QAction("Quit", self)
        quit_action.setShortcut(QKeySequence("Meta+Q"))
        quit_action.triggered.connect(QApplication.quit)
        file_menu.addAction(quit_action)

    def closeEvent(self, event):
        if self.central_widget.is_processing:
            reply = QMessageBox.question(
                self,
                "Are you sure to quit?",
                "Are you sure you want to quit?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            if reply == QMessageBox.StandardButton.No:
                event.ignore()
                return

        # Ê∏ÖÁêÜÂ§öËøõÁ®ãÁÆ°ÁêÜÂô®ËµÑÊ∫ê
        if hasattr(self.central_widget, 'multiprocess_manager'):
            self.central_widget.multiprocess_manager.shutdown()
        
        # Ê∏ÖÁêÜÂÖ∂‰ªñËµÑÊ∫ê
        self.central_widget.cleanup_on_exit()
        self.central_widget.reset_ui_state()
        event.accept()


class SubtitleProcessor(QWidget):
    def __init__(self):
        super().__init__()
        self.init_settings()
        self.init_ui()

    def init_settings(self):
        # Set default display info here
        self.api_settings = {
            "base_url": OPENAI_BASE_URL, 
            "api_key": OPENAI_API_KEY,
            "model": OPENAI_MODEL,
            "custom_prompt": OPENAI_CUSTOM_PROMPT,
            "max_chars_per_batch": OPENAI_MAX_CHARS_PER_BATCH,
            "max_entries_per_batch": OPENAI_MAX_ENTRIES_PER_BATCH,
            "max_processes": MAX_PROCESSES
        }
        
        # ÂàùÂßãÂåñÂ§öËøõÁ®ãÁÆ°ÁêÜÂô®ËÄå‰∏çÊòØÁ∫øÁ®ãÊ±†
        self.init_multiprocess_manager()
        
        self.file_paths = []
        self.cache_dir = os.path.expanduser("~/Desktop/videoCache")
        self.progress_widgets = {}
        self.is_processing = False
        self.active_process_ids = set()  # Ë∑üË∏™Ê¥ªË∑ÉÁöÑËøõÁ®ãID
        self.completed_processes = 0  # Ë∑üË∏™Â∑≤ÂÆåÊàêÁöÑËøõÁ®ãÊï∞Èáè
        self.total_processes = 0  # Ë∑üË∏™ÊÄªËøõÁ®ãÊï∞Èáè
        
        # ÂàõÂª∫ÂÆöÊó∂Âô®Áî®‰∫éÊ£ÄÊü•ËøõÁ®ãÁä∂ÊÄÅ
        self.process_timer = QTimer()
        self.process_timer.timeout.connect(self.check_process_updates)
        self.process_timer.setInterval(100)  # ÊØè100msÊ£ÄÊü•‰∏ÄÊ¨°
        
        # ‰∏ãËΩΩÂØπËØùÊ°ÜÁÆ°ÁêÜ
        self.download_dialog = None
        self.model_already_loaded = False  # Ë∑üË∏™Ê®°ÂûãÊòØÂê¶Â∑≤ÁªèÂä†ËΩΩËøá

        if not os.path.exists(self.cache_dir):
            os.makedirs(self.cache_dir)
    
    def init_multiprocess_manager(self):
        """ÂàùÂßãÂåñÂ§öËøõÁ®ãÁÆ°ÁêÜÂô®"""
        # Á°ÆÂÆöÊúÄÂ§ßËøõÁ®ãÊï∞
        cpu_count = mp.cpu_count()
        is_apple_silicon = False
        
        if platform.system() == 'Darwin':
            try:
                result = subprocess.run(['sysctl', '-n', 'hw.optional.arm64'], 
                                      capture_output=True, text=True, timeout=5)
                is_apple_silicon = result.returncode == 0 and result.stdout.strip() == '1'
            except Exception:
                pass
        
        # ‰ΩøÁî®ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÁöÑËøõÁ®ãÊï∞ËÆæÁΩÆÔºåËÄå‰∏çÊòØÁ°¨ÁºñÁ†Å
        # Â¶ÇÊûúÈÖçÁΩÆÂÄºË∂ÖÂá∫ÂêàÁêÜËåÉÂõ¥ÔºåÂàôËøõË°åÈôêÂà∂
        self.max_processes = min(MAX_PROCESSES, cpu_count)  # ‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑËÆæÁΩÆÔºå‰ΩÜ‰∏çË∂ÖËøáCPUÊ†∏ÂøÉÊï∞
        
        # Âª∂ËøüÂàùÂßãÂåñÂ§öËøõÁ®ãÁÆ°ÁêÜÂô®ÔºåÈÅøÂÖçÂú® macOS .app ÊâìÂåÖÁéØÂ¢É‰∏≠Âá∫Áé∞ÂàÜÂèâÁÇ∏Âºπ
        self.multiprocess_manager = None
        
        print(f"üîß Multiprocess settings: {self.max_processes} max processes (configured: {MAX_PROCESSES})")
        print(f"üíª System: {platform.system()} - {cpu_count} cores")
        
        if is_apple_silicon:
            print("üçé Apple Silicon detected - using optimized multiprocessing")

    def _ensure_multiprocess_manager(self):
        """Á°Æ‰øùÂ§öËøõÁ®ãÁÆ°ÁêÜÂô®Â∑≤ÂàùÂßãÂåñÔºàÂª∂ËøüÂàùÂßãÂåñÔºâ"""
        if self.multiprocess_manager is None:
            # Ê†πÊçÆÂÆûÈôÖ‰ªªÂä°Êï∞ÈáèÂä®ÊÄÅË∞ÉÊï¥ËøõÁ®ãÊï∞
            from config import get_dynamic_max_processes
            task_count = len(self.video_paths) if hasattr(self, 'video_paths') and self.video_paths else len(self.file_paths) if self.file_paths else 1
            dynamic_max_processes = get_dynamic_max_processes(task_count)
            
            print(f"üîß Initializing multiprocess manager: {task_count} tasks -> {dynamic_max_processes} processes (max configured: {self.max_processes})")
            self.multiprocess_manager = MultiprocessVideoManager(max_processes=dynamic_max_processes)

    def init_ui(self):
        main_layout = QVBoxLayout()

        # Drop Area
        self.drop_area = DropArea()
        self.drop_area.filesDropped.connect(self.on_files_dropped)
        main_layout.addWidget(self.drop_area)

        # Progress Area
        self.setup_progress_area(main_layout)

        # Engine Selection
        self.setup_engine_selection(main_layout)

        # Buttons
        self.setup_buttons(main_layout)

        self.setLayout(main_layout)

    def setup_progress_area(self, main_layout):
        self.progress_area = QScrollArea()
        self.progress_area.setWidgetResizable(True)
        self.progress_container = QWidget()
        self.progress_layout = QVBoxLayout(self.progress_container)
        self.progress_area.setWidget(self.progress_container)
        main_layout.addWidget(self.progress_area)

    def setup_engine_selection(self, main_layout):
        engine_layout = QHBoxLayout()
        self.engine_selector = QComboBox()
        self.engine_selector.addItems(["Google Translate", "OpenAI Translate"])
        self.engine_selector.setStyleSheet(
            "QComboBox { color: white; border: 1px solid #444; }"
        )
        engine_layout.addWidget(self.engine_selector)
        main_layout.addLayout(engine_layout)

    def setup_buttons(self, main_layout):
        button_layout = QHBoxLayout()
        self.start_button = QPushButton("Start Processing")
        self.start_button.clicked.connect(self.process_files)
        self.start_button.setEnabled(False)

        self.settings_button = QPushButton("SETTING")
        self.settings_button.clicked.connect(self.open_settings)

        self.clear_button = QPushButton("Clear History")
        self.clear_button.clicked.connect(self.clear_progress_history)
        self.clear_button.setEnabled(False)  # ÂàùÂßãÁä∂ÊÄÅ‰∏ãÁ¶ÅÁî®

        button_layout.addWidget(self.start_button)
        button_layout.addWidget(self.settings_button)
        button_layout.addWidget(self.clear_button)
        main_layout.addLayout(button_layout)

    def on_files_dropped(self, files):
        if not self.is_processing:
            # Âè™Â§ÑÁêÜËßÜÈ¢ëÊñá‰ª∂
            video_files = []
            invalid_files = []
            
            for file_path in files:
                if self.drop_area.is_video_file(file_path):
                    video_files.append(file_path)
                else:
                    invalid_files.append(file_path)
            
            # ÊòæÁ§∫Êó†ÊïàÊñá‰ª∂Ë≠¶Âëä
            if invalid_files:
                invalid_names = [os.path.basename(f) for f in invalid_files]
                QMessageBox.warning(
                    self,
                    "Invalid File Type",
                    f"The following files are not supported video files and will be ignored:\n" + 
                    "\n".join(invalid_names),
                    QMessageBox.StandardButton.Ok,
                )
            
            self.file_paths = video_files
            
            if self.file_paths:
                self.setup_progress_widgets()
                self.start_button.setEnabled(True)
            else:
                self.start_button.setEnabled(False)
        else:
            QMessageBox.warning(
                self,
                "Processing",
                "Wait for the current task to complete before adding a new file",
                QMessageBox.StandardButton.Ok,
            )

    def setup_progress_widgets(self):
        while self.progress_layout.count():
            child = self.progress_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        self.progress_widgets = {}
        for file_path in self.file_paths:
            base_name = os.path.basename(file_path)
            progress_widget = ProgressWidget(base_name)
            self.progress_widgets[base_name] = progress_widget
            self.progress_layout.addWidget(progress_widget)
        
        # Â¶ÇÊûúÊúâËøõÂ∫¶Êù°ÔºåÂêØÁî®Ê∏ÖÈô§ÊåâÈíÆ
        if self.progress_widgets:
            self.clear_button.setEnabled(True)

    def clear_progress_history(self):
        """Ê∏ÖÈô§ËøõÂ∫¶ÂéÜÂè≤"""
        if not self.is_processing:
            while self.progress_layout.count():
                child = self.progress_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            self.progress_widgets = {}
            self.clear_button.setEnabled(False)

    def process_files(self):
        """Â§ÑÁêÜËßÜÈ¢ëÊñá‰ª∂ - Â§öËøõÁ®ãÁâàÊú¨"""
        if not self.file_paths:
            QMessageBox.warning(
                self, "Warning", "Select the file before processing", QMessageBox.StandardButton.Ok
            )
            return

        # Áõ¥Êé•Â§ÑÁêÜËßÜÈ¢ë
        self.process_videos()

    def process_videos(self):
        """Â§ÑÁêÜËßÜÈ¢ë - Â§öËøõÁ®ãÁâàÊú¨"""
        if not hasattr(self, 'video_paths') or not self.video_paths:
            # Â¶ÇÊûúÊ≤°Êúâvideo_pathsÔºå‰ΩøÁî®file_paths
            if not self.file_paths:
                QMessageBox.warning(
                    self, "Warning", "Select the file before processing", QMessageBox.StandardButton.Ok
                )
                return
            self.video_paths = self.file_paths

        # Ê∏ÖÁêÜËøõÂ∫¶ÊòæÁ§∫Âå∫Âüü
        while self.progress_layout.count():
            child = self.progress_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        self.progress_widgets = {}

        # ËÆæÁΩÆÊñ∞ÁöÑËøõÂ∫¶ÊòæÁ§∫
        self.setup_progress_widgets()

        # Á¶ÅÁî®UIÊéß‰ª∂
        self.start_button.setEnabled(False)
        self.engine_selector.setEnabled(False)
        self.settings_button.setEnabled(False)
        self.clear_button.setEnabled(False)
        self.is_processing = True
        self.drop_area.setEnabled(False)
        
        # ÈáçÁΩÆËÆ°Êï∞Âô®ÂíåË∑üË∏™Âô®
        self.completed_processes = 0
        self.total_processes = len(self.video_paths)
        self.active_process_ids.clear()

        # Á°Æ‰øùÂ§öËøõÁ®ãÁÆ°ÁêÜÂô®Â∑≤ÂàùÂßãÂåñ
        self._ensure_multiprocess_manager()

        # ÂêØÂä®ÊâÄÊúâËßÜÈ¢ëÂ§ÑÁêÜËøõÁ®ã
        for video_path in self.video_paths:
            try:
                process_id = self.multiprocess_manager.submit_video(
                    video_path=video_path,
                    engine=self.engine_selector.currentText(),
                    api_settings=self.api_settings,
                    cache_dir=self.cache_dir
                )
                
                self.active_process_ids.add(process_id)
                print(f"üöÄ Submitted video {os.path.basename(video_path)} to process {process_id}")
                
            except Exception as e:
                self.handle_error(f"Error starting processor for {os.path.basename(video_path)}: {str(e)}")

        # ÂêØÂä®ÂÆöÊó∂Âô®Ê£ÄÊü•ËøõÁ®ãÁä∂ÊÄÅ
        self.process_timer.start()
    
    def check_process_updates(self):
        """Ê£ÄÊü•ËøõÁ®ãÊõ¥Êñ∞ - ÂÆöÊó∂Âô®ÂõûË∞É"""
        try:
            # Â¶ÇÊûúÂ§öËøõÁ®ãÁÆ°ÁêÜÂô®Êú™ÂàùÂßãÂåñÔºåË∑≥ËøáÊ£ÄÊü•
            if self.multiprocess_manager is None:
                return
                
            # Ëé∑ÂèñËøõÂ∫¶Êõ¥Êñ∞
            progress_updates = self.multiprocess_manager.get_progress_updates()
            for update in progress_updates:
                if update['type'] == 'progress':
                    self.update_file_progress(update['base_name'], update['progress'])
                    if 'elapsed_time' in update:
                        self.update_file_timer(update['base_name'], update['elapsed_time'])
                elif update['type'] == 'status':
                    self.update_file_status(update['base_name'], update['status'])
            
            # Ëé∑ÂèñÂ§ÑÁêÜÁªìÊûú
            results = self.multiprocess_manager.get_results()
            for result in results:
                process_id = result['process_id']
                video_path = result['video_path']
                base_name = os.path.basename(video_path)
                
                if process_id in self.active_process_ids:
                    self.active_process_ids.remove(process_id)
                    self.completed_processes += 1
                    
                    if result['status'] == 'success':
                        print(f"‚úÖ Process {process_id} completed successfully: {base_name}")
                        if base_name in self.progress_widgets:
                            self.progress_widgets[base_name].update_status("Processing completed!")
                            self.progress_widgets[base_name].update_progress(100)
                    elif result['status'] == 'error':
                        error_msg = result.get('error', 'Unknown error')
                        print(f"‚ùå Process {process_id} failed: {base_name} - {error_msg}")
                        self.handle_error(f"Failed to process {base_name}: {error_msg}")
                    
                    # Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâËøõÁ®ãÈÉΩÂ∑≤ÂÆåÊàê
                    if self.completed_processes >= self.total_processes:
                        self.all_processes_completed()
            
        except Exception as e:
            print(f"Error checking process updates: {str(e)}")
    
    def all_processes_completed(self):
        """ÊâÄÊúâËøõÁ®ãÂÆåÊàêÂêéÁöÑÂ§ÑÁêÜ"""
        print("üéâ All video processing completed")
        
        # ÂÅúÊ≠¢ÂÆöÊó∂Âô®
        self.process_timer.stop()
        
        # ÈáçÁΩÆÁä∂ÊÄÅ
        self.reset_ui_state_keep_progress()
        
        # ÊòæÁ§∫ÂÆåÊàêÊ∂àÊÅØ
        QMessageBox.information(
            self, "Processing", "All processing is complete!", QMessageBox.StandardButton.Ok
        )

    def update_file_progress(self, file_name, progress):
        if file_name in self.progress_widgets:
            self.progress_widgets[file_name].update_progress(progress)

    def update_file_status(self, file_name, status):
        if file_name in self.progress_widgets:
            self.progress_widgets[file_name].update_status(status)

    def update_file_timer(self, file_name, elapsed_time):
        if file_name in self.progress_widgets:
            self.progress_widgets[file_name].update_timer(elapsed_time)

    def handle_error(self, error_message):
        """Â§ÑÁêÜÈîôËØØ - Â§öËøõÁ®ãÁâàÊú¨"""
        print(f"‚ùå Error: {error_message}")
        # Ê≥®ÊÑèÔºö‰∏çÈúÄË¶ÅÊâãÂä®ÁÆ°ÁêÜÂÆåÊàêËÆ°Êï∞ÔºåÂõ†‰∏∫check_process_updates‰ºöÂ§ÑÁêÜ
        # ÂèØ‰ª•ÈÄâÊã©ÊÄßÂú∞ÊòæÁ§∫ÈîôËØØÂØπËØùÊ°Ü
        # QMessageBox.critical(self, "Processing error", error_message, QMessageBox.StandardButton.Ok)

    def handle_finished(self):
        """Â§ÑÁêÜÂÆåÊàê - Â§öËøõÁ®ãÁâàÊú¨Ôºà‰øùÁïôÂÖºÂÆπÊÄßÔºâ"""
        # Ê≥®ÊÑèÔºöÂú®Â§öËøõÁ®ãÁâàÊú¨‰∏≠ÔºåÂÆåÊàêÂ§ÑÁêÜÁî±check_process_updatesÂíåall_processes_completedÂ§ÑÁêÜ
        # Ëøô‰∏™ÊñπÊ≥ï‰øùÁïôÊòØ‰∏∫‰∫ÜÂêëÂêéÂÖºÂÆπÔºå‰ΩÜÂÆûÈôÖ‰∏ä‰∏ç‰ºöË¢´Ë∞ÉÁî®
        pass

    def open_settings(self):
        dialog = ApiSettingsDialog(self, self.api_settings)
        if dialog.exec():
            # Update the max_processes value used by the multiprocess manager
            old_max_processes = self.max_processes
            self.max_processes = self.api_settings["max_processes"]
            
            # If multiprocess manager exists and max_processes changed, reset it
            if (self.multiprocess_manager is not None and 
                old_max_processes != self.max_processes):
                print(f"üîß Updating max_processes from {old_max_processes} to {self.max_processes}")
                # Clean up existing manager
                self.multiprocess_manager.cleanup()
                # Reset manager to None so it will be recreated with new settings
                self.multiprocess_manager = None
            
            # Save settings to config file
            save_config(
                self.api_settings["base_url"], 
                self.api_settings["api_key"],
                self.api_settings["model"],
                self.api_settings["custom_prompt"],
                self.api_settings["max_chars_per_batch"],
                self.api_settings["max_entries_per_batch"],
                self.api_settings["max_processes"]
            )

            # QMessageBox.information(
            #     self,
            #     "Save Settings",
            #     "API Settings have been updated and saved",
            #     QMessageBox.StandardButton.Ok,
            # )

    def reset_ui_state(self):
        self.is_processing = False
        self.drop_area.setEnabled(True)
        # ÈáçÁΩÆÊãñÊãΩÂå∫Âüü‰∏∫ËßÜÈ¢ëÊñá‰ª∂ÊèêÁ§∫ÊñáÊú¨
        self.drop_area.reset_state("Drag and Drop Video Files")
        self.file_paths = []  # ÈáçÁΩÆÈÄöÁî®Êñá‰ª∂Ë∑ØÂæÑ
        # ‰∏∫‰∫ÜÂÖºÂÆπÊÄßÔºå‰πüÈáçÁΩÆvideo_pathsÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ
        if hasattr(self, 'video_paths'):
            self.video_paths = []
        self.start_button.setEnabled(False)
        self.engine_selector.setEnabled(True)
        self.settings_button.setEnabled(True)
        
        # Ê∏ÖÁêÜÂ§ÑÁêÜÂô®ÂàóË°®
        self.active_processors.clear()

        # Ê∏ÖÁêÜËøõÂ∫¶ÊòæÁ§∫Âå∫Âüü
        while self.progress_layout.count():
            child = self.progress_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        self.progress_widgets = {}

    def reset_ui_state_keep_progress(self):
        """ÈáçÁΩÆUIÁä∂ÊÄÅ‰ΩÜ‰øùÁïôËøõÂ∫¶Êù° - Â§öËøõÁ®ãÁâàÊú¨"""
        self.is_processing = False
        self.drop_area.setEnabled(True)
        self.drop_area.reset_state("Drag and Drop Video Files")
        self.file_paths = []
        if hasattr(self, 'video_paths'):
            self.video_paths = []
        self.start_button.setEnabled(False)
        self.engine_selector.setEnabled(True)
        self.settings_button.setEnabled(True)
        self.clear_button.setEnabled(True)  # ÈáçÊñ∞ÂêØÁî®Ê∏ÖÈô§ÊåâÈíÆ
        
        # ÈáçÁΩÆËÆ°Êï∞Âô®
        self.completed_processes = 0
        self.total_processes = 0
        self.active_process_ids.clear()
        
    def cleanup_on_exit(self):
        """Â∫îÁî®ÈÄÄÂá∫Êó∂ÁöÑÊ∏ÖÁêÜÂ∑•‰Ωú - Â§öËøõÁ®ãÁâàÊú¨"""
        try:
            # ÂÅúÊ≠¢ÂÆöÊó∂Âô®
            if hasattr(self, 'process_timer'):
                self.process_timer.stop()
            
            # ÂÖ≥Èó≠Â§öËøõÁ®ãÁÆ°ÁêÜÂô®
            if hasattr(self, 'multiprocess_manager') and self.multiprocess_manager is not None:
                self.multiprocess_manager.shutdown()
                
        except Exception as e:
            print(f"Cleanup error: {e}")  # ‰ΩøÁî®printÈÅøÂÖçÊó•ÂøóÈóÆÈ¢ò

    def show_download_dialog(self, model_name):
        """ÊòæÁ§∫‰∏ãËΩΩËøõÂ∫¶ÂØπËØùÊ°Ü"""
        # Â¶ÇÊûúÊ®°ÂûãÂ∑≤ÁªèÂä†ËΩΩËøáÔºåÂ∞±‰∏çÊòæÁ§∫‰∏ãËΩΩÂØπËØùÊ°Ü
        if self.model_already_loaded:
            return
            
        if self.download_dialog is None:
            self.download_dialog = DownloadDialog(self)
        
        self.download_dialog.show()
        self.download_dialog.raise_()
        self.download_dialog.activateWindow()
        self.download_dialog.add_log(f"Starting download of {model_name} model")
    
    def update_download_progress(self, percentage, downloaded_mb, total_mb, speed_mbps):
        """Êõ¥Êñ∞‰∏ãËΩΩËøõÂ∫¶"""
        if self.model_already_loaded:
            return
        if self.download_dialog:
            self.download_dialog.update_progress(percentage, downloaded_mb, total_mb, speed_mbps)
    
    def update_download_status(self, message):
        """Êõ¥Êñ∞‰∏ãËΩΩÁä∂ÊÄÅ"""
        if self.model_already_loaded:
            return
        if self.download_dialog:
            self.download_dialog.update_status(message)
    
    def download_completed(self):
        """‰∏ãËΩΩÂÆåÊàêÂ§ÑÁêÜ"""
        self.model_already_loaded = True  # Ê†áËÆ∞Ê®°ÂûãÂ∑≤ÁªèÂä†ËΩΩÂÆåÊàê
        if self.download_dialog:
            self.download_dialog.set_completed()
    
    def download_error(self, error_message):
        """‰∏ãËΩΩÈîôËØØÂ§ÑÁêÜ"""
        if self.download_dialog:
            self.download_dialog.set_error(error_message)
        else:
            # Â¶ÇÊûúÂØπËØùÊ°Ü‰∏çÂ≠òÂú®ÔºåÊòæÁ§∫ÈîôËØØÊ∂àÊÅØÊ°Ü
            QMessageBox.critical(
                self, 
                "Download Error", 
                f"Failed to download speech recognition model:\n{error_message}", 
                QMessageBox.StandardButton.Ok
            )
